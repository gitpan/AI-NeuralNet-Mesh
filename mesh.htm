<HTML>
<HEAD>
<TITLE>AI::NeuralNet::Mesh - An optimized, accurate neural network Mesh.</TITLE>
<LINK REV="made" HREF="mailto:">
<STYLE>
	BODY { font-family:Verdana; font-size:11; color:black; }
	CODE { background: rgb(200,200,200); }
	PRE	 { background:rgb(220,220,220); padding: 5; border:1px black solid; }
	A:link    {font-family:Verdana, Arial, Helvetica, Helv; font-size:10px; text-decoration:underline; font-weight:normal; color:rgb(58,73,114);}
	A:visited {font-family:Verdana, Arial, Helvetica, Helv; font-size:10px; text-decoration:normal; font-weight:normal; color:rgb(58,73,114);}
	A:hover   {font-family:Verdana, Arial, Helvetica, Helv; font-size:10px; text-decoration:underline; font-weight:normal; color:rgb(200,50,0);}
</STYLE>
</HEAD>

<BODY>

<PRE>
<B>AI::NeuralNet::Mesh</B> - An optimized, accurate neural network Mesh.
</PRE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#version & updates">VERSION &amp; UPDATES</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#whats different">WHATS DIFFERENT?</A></LI>
	<UL>

		<LI><A HREF="#mesh connections">MESH CONNECTIONS</A></LI>
		<LI><A HREF="#learning style">LEARNING STYLE</A></LI>
	</UL>

	<LI><A HREF="#methods">METHODS</A></LI>
	<LI><A HREF="#what can it do">WHAT CAN IT DO?</A></LI>
	<LI><A HREF="#examples">EXAMPLES</A></LI>
	<LI><A HREF="#other included packages">OTHER INCLUDED PACKAGES</A></LI>
	<LI><A HREF="#bugs">BUGS</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#download">DOWNLOAD</A></LI>
	<LI><A HREF="#mailing list">MAILING LIST</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>AI::NeuralNet::Mesh - An optimized, accurate neural network Mesh.</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
        my $net = new AI::NeuralNet::Mesh(2,2,1);</PRE>
<P>
<HR>
<H1><A NAME="version & updates">VERSION &amp; UPDATES</A></H1>
<P>This is version <STRONG>0.20</STRONG>, the first release of this module.</P>
<P><B>FEEDBACK</B> - Feedback is good. Feeedback is very good. No, not for my ego. :) Please
write and let me know how your are using the module and/or how you think it could be better! 
Flames/comments/critiques are all welcome and appreciated.
</P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>AI::NeuralNet::Mesh is an optimized, accurate neural network Mesh.
It was designed with accruacy and speed in mind. This is a neural
net simulator similar to AI::NeuralNet::BackProp, but with several
important differences. The two APIs are the same, that of this module
and ::BackProp, so any scripts that use ::BackProp, should be able
to use this module without (almost) any changes in your code. (The 
only changes needed will be to change the ``use'' line and the ``new'' 
constructor line to use ::Mesh instead of ::BackProp.)</P>
<P>This is a complete, from-scratch re-write of the Perl module 
AI::NeuralNet::BackProp. It a method of learning similar to 
back propogation, yet with a few custom modifications, includeding
a specialized output layer, as well as a better descent model for 
learning.</P>
<P>Almost all of the notes and description in AI::NeuralNet::BackProp
apply to this module, yet the differences I will detail below. I
also have included a complete working function refrence here, with
the updates added.</P>
<P>
<HR>
<H1><A NAME="whats different">WHATS DIFFERENT?</A></H1>
<P>
<H2><A NAME="mesh connections">MESH CONNECTIONS</A></H2>
<P>In AI::NeuralNet::BackProp, the neurons would be connected like this:</P>
<PRE>
     output
     /  \
    O    O
    |\  /|
    | \/ |
    | /\ |
    |/  \|
    O    O
     \  /
    input
</PRE>

<P>
In this module, I have made a couple of important changes to the connection
map. Consider this digram (This has 2 layers, 2 nodes/layer, 1 output node):</P>


<PRE>

 data collector 
       ^
       |
       O       &lt;-- OUTPUT LAYER
      / \  
     /   \
    O     O    &lt;-- LAYER 2
    |\   /|
    | \ / |
    | / \ |
    |/   \|
    O     O    &lt;-- LAYER 1
    |     | 
    ^     ^
  input array</PRE>

<P>
The mesh model includes an extra output &quot;layer&quot; above the final layer 
specified in the constructor. If the constructor had specified 2 layers,
2 nodes/layer, and B&lt;2&gt; output nodes, then the mesh would look like this:</P>
<PRE>
 data collector 
    ^     ^
    |     |
    O     O    &lt;-- OUTPUT LAYER
    |     |
    |     |
    O     O    &lt;-- LAYER 2
    |\   /|
    | \ / |
    | / \ |
    |/   \|
    O     O    &lt;-- LAYER 1
    |     | 
    ^     ^
  input array</PRE>
<P>As you can see, the mesh creator adds one node in the output layer for
every node called for in the constructor. This adds an node
for that output, allowing better accuracy in the network, 
whereas in AI::NeuralNet::BackProp the output nodes were not allowed to be 
weighted.</P>
<P>
<H2><A NAME="learning style">LEARNING STYLE</A></H2>
<P>In this module I have included a more accurate form of ``learning'' for the
mesh. This form preforms descent toward a local error minimum (0) on a 
directional delta, rather than the desired value for that node. This allows
for better, and more accurate results with larger datasets. This module also
uses a simpler recursion technique which, suprisingly, is more accurate than
the original technique that I used in AI::NeuralNet::BackProp.</P>
<P>By way of accuracy example, the included example script ``examples/ex_dow.pl'',
upon the third learning loop (using AI::NeuralNet::BackProp), would almost
always report forgetfulness around 25.00000% (rounded to five decimals), 
whereas when running the same example and the same example code with 
AI::NeuralNet::Mesh and only <STRONG>one</STRONG> learning loop, it reports forgetfulness 
of less than <EM>2.00227</EM>! Over twenty-two percent increase in accuracy on one 
script alone.</P>
<P>The learning is also speed up immensly. Whereas the above mentioned script 
often take up to a half hour or more on my systems to learn the example data 
with the old AI::NeuralNet::BackProp module, it now (with this module) takes 
less than <EM>forty seconds</EM> to learn the data set (one loop).</P>
<P>
<HR>
<H1><A NAME="methods">METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_BackProp">new AI::NeuralNet::BackProp($layers, $nodes [, $outputs])</A></STRONG><BR>
<DD>
Returns a newly created neural network from an <CODE>AI::NeuralNet::Mesh</CODE>
object. The network will have <CODE>$layers</CODE> number of layers in it
and it will have <CODE>$nodes</CODE> number of nodes per layer.
<P>There is an optional parameter of $outputs, which specifies the number
of output neurons to provide. If $outputs is not specified, $outputs
defaults to equal $size.</P>
<P>Before you can really do anything useful with your new neural network
object, you need to teach it some patterns. See the <A HREF="#item_learn"><CODE>learn()</CODE></A> method, below.</P>
<P></P>
<DT><STRONG><A NAME="item_learn">$net-&gt;learn($input_map_ref, $desired_result_ref [, options ]);</A></STRONG><BR>
<DD>
This will 'teach' a network to associate an new input map with a desired 
result. It will return a string containg benchmarking information.
<P>You can also specify strings as inputs and ouputs to learn, and they will be 
crunched automatically. Example:</P>
<PRE>
        $net-&gt;learn('corn', 'cob');
</PRE>

<P>
Note, the old method of calling crunch on the values still works just as well.</P>
<P>The first two arguments may be array refs (or now, strings), and they may be 
of different lengths.</P>
<P>Options should be written on hash form. There are three options:
</P>
<PRE>
         inc    =&gt;      $learning_gradient
         max    =&gt;      $maximum_iterations
         error  =&gt;      $maximum_allowable_percentage_of_error</PRE>
<P>$learning_gradient is an optional value used to adjust the weights of the internal
connections. If $learning_gradient is ommitted, it defaults to 0.10.
</P>
<P>$maximum_iterations is the maximum numbers of iteration the loop should do.
It defaults to 1024.  Set it to 0 if you never want the loop to quit before
the pattern is perfectly learned.</P>
<P>$maximum_allowable_percentage_of_error is the maximum allowable error to have. If 
this is set, then <A HREF="#item_learn"><CODE>learn()</CODE></A> will return when the perecentage difference between the
actual results and desired results falls below $maximum_allowable_percentage_of_error.
If you do not include 'error', or $maximum_allowable_percentage_of_error is set to -1,
then <A HREF="#item_learn"><CODE>learn()</CODE></A> will not return until it gets an exact match for the desired result OR it
reaches $maximum_iterations.</P>
<P></P>
<DT><STRONG><A NAME="item_learn_set">$net-&gt;learn_set(\@set, [ options ]);</A></STRONG><BR>
<DD>
This takes the same options as <A HREF="#item_learn"><CODE>learn()</CODE></A> (learn_set() uses <A HREF="#item_learn"><CODE>learn()</CODE></A> internally) 
and allows you to specify a set to learn, rather than individual patterns. 
A dataset is an array refrence with at least two elements in the array, 
each element being another array refrence (or now, a scalar string). For 
each pattern to learn, you must specify an input array ref, and an ouput 
array ref as the next element. Example:

<PRE>
        my @set = (
                # inputs        outputs
                [ 1,2,3,4 ],  [ 1,3,5,6 ],
                [ 0,2,5,6 ],  [ 0,2,1,2 ]
        );</PRE>
<P>Inputs and outputs in the dataset can also be strings.</P>
<P>See the paragraph on measuring forgetfulness, below. There are 
two learn_set()-specific option tags available:</P>
<PRE>
        flag     =&gt;  $flag
        pattern  =&gt;  $row</PRE>
<P>If ``flag'' is set to some TRUE value, as in ``flag =&gt; 1'' in the hash of options, or if the option ``flag''
is not set, then it will return a percentage represting the amount of forgetfullness. Otherwise,
<A HREF="#item_learn_set"><CODE>learn_set()</CODE></A> will return an integer specifying the amount of forgetfulness when all the patterns 
are learned.</P>
<P>If ``pattern'' is set, then <A HREF="#item_learn_set"><CODE>learn_set()</CODE></A> will use that pattern in the data set to measure forgetfulness by.
If ``pattern'' is omitted, it defaults to the first pattern in the set. Example:</P>
<PRE>
        my @set = (
                [ 0,1,0,1 ],  [ 0 ],
                [ 0,0,1,0 ],  [ 1 ],
                [ 1,1,0,1 ],  [ 2 ],  #  &lt;---
                [ 0,1,1,0 ],  [ 3 ]
        );
</PRE>
<P>
If you wish to measure forgetfulness as indicated by the line with the arrow, then you would
pass 2 as the &quot;pattern&quot; option, as in &quot;pattern =&gt; 2&quot;.</P>
<P>Now why the heck would anyone want to measure forgetfulness, you ask? Maybe you wonder how I 
even measure that. Well, it is not a vital value that you have to know. I just put in a 
``forgetfulness measure'' one day because I thought it would be neat to know.</P>
<P>How the module measures forgetfulness is this: First, it learns all the patterns 
in the set provided, then it will run the very first pattern (or whatever pattern
is specified by the ``row'' option) in the set after it has finished learning. It 
will compare the <A HREF="#item_run"><CODE>run()</CODE></A> output with the desired output as specified in the dataset. 
In a perfect world, the two should match exactly. What we measure is how much that 
they don't match, thus the amount of forgetfulness the network has.</P>
<P>Example (from examples/ex_dow.pl):</P>
<PRE>
        # Data from 1989 (as far as I know..this is taken from example data on BrainMaker)
        my @data = ( 
                #       Mo  CPI  CPI-1 CPI-3    Oil  Oil-1 Oil-3    Dow   Dow-1 Dow-3   Dow Ave (output)
                [       1,      229, 220,  146,         20.0, 21.9, 19.5,       2645, 2652, 2597],      [       2647  ],
                [       2,      235, 226,  155,         19.8, 20.0, 18.3,       2633, 2645, 2585],      [       2637  ],
                [       3,      244, 235,  164,         19.6, 19.8, 18.1,       2627, 2633, 2579],      [       2630  ],
                [       4,      261, 244,  181,         19.6, 19.6, 18.1,       2611, 2627, 2563],      [       2620  ],
                [       5,      276, 261,  196,         19.5, 19.6, 18.0,       2630, 2611, 2582],      [       2638  ],
                [       6,      287, 276,  207,         19.5, 19.5, 18.0,       2637, 2630, 2589],      [       2635  ],
                [       7,      296, 287,  212,         19.3, 19.5, 17.8,       2640, 2637, 2592],      [       2641  ]                 
        );

        # Learn the set
        my $f = $net-&gt;learn_set(\@data, 
                                          inc   =&gt;      0.1,    
                                          max   =&gt;      500,
                                         );

        # Print it 
        print &quot;Forgetfullness: $f%&quot;;</PRE>
<P></P>
<P>
This is a snippet from the example script examples/finance.pl, which demonstrates DOW average
prediction for the next month. A more simple set defenition would be as such:</P>
<PRE>
        my @data = (
                [ 0,1 ], [ 1 ],
                [ 1,0 ], [ 0 ]
        );

        $net-&gt;learn_set(\@data);</PRE>
<P>
Same effect as above, but not the same data (obviously).</P>
<P></P>
<DT><STRONG><A NAME="item_run">$net-&gt;run($input_map_ref);</A></STRONG><BR>
<DD>
NOTE: This is a deviation from the AI::NeuralNet::BackProp API.
In ::BackProp, <A HREF="#item_run"><CODE>run()</CODE></A> automatically benchmarked itself. In ::Mesh <A HREF="#item_run"><CODE>run()</CODE></A> does
not do this inorder to speed up <A HREF="#item_learn"><CODE>learn()</CODE></A> by as much as 10-20 seconds on small
data sets. Even larger speed increases are realized on larger data sets.
<P>This method will apply the given array ref at the input layer of the neural network, and
it will return an array ref to the output of the network. <A HREF="#item_run"><CODE>run()</CODE></A> will now automatically <A HREF="#item_crunch"><CODE>crunch()</CODE></A> 
a string given as an input.</P>
<P>Example Usage:
</P>
<PRE>

        my $inputs  = [ 1,1,0,1 ];
        my $outputs = $net-&gt;run($inputs);</PRE>
<P>You can also do this with a string:</P>
<PRE>
        my $outputs = $net-&gt;run('cloudy, wind is 5 MPH NW');</PRE>
<P>See also <A HREF="#item_run_uc"><CODE>run_uc()</CODE></A> below.</P>
<P></P>
<DT><STRONG><A NAME="item_run_uc">$net-&gt;run_uc($input_map_ref);</A></STRONG><BR>
<DD>
This method does the same thing as this code:

<PRE>

        $net-&gt;uncrunch($net-&gt;run($input_map_ref));</PRE>
<P>All that <A HREF="#item_run_uc"><CODE>run_uc()</CODE></A> does is that it automatically calls <A HREF="#item_uncrunch"><CODE>uncrunch()</CODE></A> on the output, regardless
of whether the input was <A HREF="#item_crunch"><CODE>crunch()</CODE></A> -ed or not.</P>
<P></P>
<DT><STRONG><A NAME="item_range">$net-&gt;range();</A></STRONG><BR>
<DD>
NOTE: This is a deviation from the AI::NeuralNet::BackProp API.
::BackProp has <A HREF="#item_range"><CODE>range()</CODE></A> enabled, ::Mesh does not.
<P>In this module, <A HREF="#item_range"><CODE>range()</CODE></A> is disabled. It is included as a function stub
to comply with the API established by AI::NeuralNet::BackProp. I have 
included the full code to the two essential parts of <A HREF="#item_range"><CODE>range()</CODE></A> in the module
file, though. If anyone feels up to it, they can attempt to get <A HREF="#item_range"><CODE>range()</CODE></A> 
working on their own. If you do get range working, please send me a copy! :-)</P>
<P></P>
<DT><STRONG><A NAME="item_benchmark">$net-&gt;benchmark();<BR>
$net-&gt;benchmarked();</A></STRONG><BR>
<DD>
NOTE: This is a deviation from the AI::NeuralNet::BackProp API.
In ::BackProp, <CODE>benchmarked()</CODE> returns benchmark info for last <A HREF="#item_run"><CODE>run()</CODE></A> call.
In ::Mesh it only will return info for the last <A HREF="#item_learn"><CODE>learn()</CODE></A> call. <CODE>benchmarked()</CODE>
is an alias for <A HREF="#item_benchmark"><CODE>benchmark()</CODE></A> so we don't break any scripts..
<P>This returns a benchmark info string for the last <A HREF="#item_learn"><CODE>learn()</CODE></A> call.
It is easily printed as a string, as following:</P>
<PRE>
        print &quot;Last learn() took &quot;,$net-&gt;benchmark(),&quot;\n&quot;;</PRE>
<P></P>
<DT><STRONG><A NAME="item_debug">$net-&gt;debug($level)</A></STRONG><BR>
<DD>
Toggles debugging off if called with $level = 0 or no arguments. There are four levels
of debugging.
<P>NOTE: Debugging verbosity has been toned down somewhat from AI::NeuralNet::BackProp,
but level 4 still prints the same amount of information as you were used too. The other
levels, however, are mostly for really advanced use. Not much explanation in the other
levels, but they are included for those of you that feel daring (or just plain bored.)</P>
<P>Level 0 ($level = 0) : Default, no debugging information printed. All printing is 
left to calling script.</P>
<P>Level 1 ($level = 1) : Displays the activity between nodes, prints what values were
received and what they were weighted too.</P>
<P>Level 2 ($level = 2) : I don't think I included any level 2 debugs in this version.</P>
<P>Level 3 ($level = 3) : Just prints info from the <CODE>lear()</CODE> loop, in the form of ``got: X, wanted Y''
type of information.</P>
<P>Level 4 ($level = 4) : This level is the one I use most. It is only used during learning. It
displays the current error (difference between actual outputs and the target outputs you
asked for), as well as the current loop number and the benchmark time for the last learn cycle.
Also printed are the actual outputs and the target outputs below the benchmark times.</P>
<P>Toggles debuging off when called with no arguments.</P>
<P></P>
<DT><STRONG><A NAME="item_save">$net-&gt;save($filename);</A></STRONG><BR>
<DD>
This will save the complete state of the network to disk, including all weights and any
words crunched with <A HREF="#item_crunch"><CODE>crunch()</CODE></A> . Also saves any output ranges set with <A HREF="#item_range"><CODE>range()</CODE></A> .
<P>This uses a simple flat-file text storage format, and therefore the network files should
be fairly portable.</P>
<P>This method will return undef if there was a problem with writing the file. If there is an
error, it will set the internal error message, which you can retrive with the <A HREF="#item_error"><CODE>error()</CODE></A> method,
below.</P>
<P>If there were no errors, it will return a refrence to $net.</P>
<P></P>
<DT><STRONG><A NAME="item_load">$net-&gt;load($filename);</A></STRONG><BR>
<DD>
This will load from disk any network saved by <A HREF="#item_save"><CODE>save()</CODE></A> and completly restore the internal
state at the point it was <A HREF="#item_save"><CODE>save()</CODE></A> was called at.
<P>If the file doesn't exist, or if the file is of an invalid file type, then <A HREF="#item_load"><CODE>load()</CODE></A> will
return undef. To determine what caused the error, use the <A HREF="#item_error"><CODE>error()</CODE></A> method, beelow.</P>
<P>If there were no errors, it will return a refrence to $net.</P>
<P></P>
<DT><STRONG><A NAME="item_join_cols">$net-&gt;join_cols($array_ref,$row_length_in_elements,$high_state_character,$low_state_character);</A></STRONG><BR>
<DD>
This is more of a utility function than any real necessary function of the package.
Instead of joining all the elements of the array together in one long string, like <CODE>join()</CODE> ,
it prints the elements of $array_ref to STDIO, adding a newline (\n) after every $row_length_in_elements
number of elements has passed. Additionally, if you include a $high_state_character and a $low_state_character,
it will print the $high_state_character (can be more than one character) for every element that
has a true value, and the $low_state_character for every element that has a false value. 
If you do not supply a $high_state_character, or the $high_state_character is a null or empty or 
undefined string, it <A HREF="#item_join_cols"><CODE>join_cols()</CODE></A> will just print the numerical value of each element seperated
by a null character (\0). <A HREF="#item_join_cols"><CODE>join_cols()</CODE></A> defaults to the latter behaviour.
<P></P>
<DT><STRONG><A NAME="item_pdiff">$net-&gt;pdiff($array_ref_A, $array_ref_B);</A></STRONG><BR>
<DD>
This function is used VERY heavily internally to calculate the difference in percent
between elements of the two array refs passed. It returns a %.20f (sprintf-format) 
percent sting.
<P></P>
<DT><STRONG><A NAME="item_p">$net-&gt;p($a,$b);</A></STRONG><BR>
<DD>
Returns a floating point number which represents $a as a percentage of $b.
<P></P>
<DT><STRONG><A NAME="item_intr">$net-&gt;intr($float);</A></STRONG><BR>
<DD>
Rounds a floating-point number rounded to an integer using <CODE>sprintf()</CODE> and <CODE>int()</CODE> , Provides
better rounding than just calling <CODE>int()</CODE> on the float. Also used very heavily internally.
<P></P>
<DT><STRONG><A NAME="item_high">$net-&gt;high($array_ref);</A></STRONG><BR>
<DD>
Returns the index of the element in array REF passed with the highest comparative value.
<P></P>
<DT><STRONG><A NAME="item_low">$net-&gt;low($array_ref);</A></STRONG><BR>
<DD>
Returns the index of the element in array REF passed with the lowest comparative value.
<P></P>
<DT><STRONG><A NAME="item_show">$net-&gt;show();</A></STRONG><BR>
<DD>
This will dump a simple listing of all the weights of all the connections of every neuron
in the network to STDIO.
<P></P>
<DT><STRONG><A NAME="item_crunch">$net-&gt;crunch($string);</A></STRONG><BR>
<DD>
This splits a string passed with /[\s\t]/ into an array ref containing unique indexes
to the words. The words are stored in an intenal array and preserved across <A HREF="#item_load"><CODE>load()</CODE></A> and <A HREF="#item_save"><CODE>save()</CODE></A>
calls. This is designed to be used to generate unique maps sutible for passing to <A HREF="#item_learn"><CODE>learn()</CODE></A> and 
<A HREF="#item_run"><CODE>run()</CODE></A> directly. It returns an array ref.
<P>The words are not duplicated internally. For example:</P>
<PRE>
        $net-&gt;crunch(&quot;How are you?&quot;);</PRE>
<P>Will probably return an array ref containing 1,2,3. A subsequent call of:</P>
<PRE>
    $net-&gt;crunch(&quot;How is Jane?&quot;);</PRE>
<P>Will probably return an array ref containing 1,4,5. Notice, the first element stayed
the same. That is because it already stored the word ``How''. So, each word is stored
only once internally and the returned array ref reflects that.</P>
<P></P>
<DT><STRONG><A NAME="item_uncrunch">$net-&gt;uncrunch($array_ref);</A></STRONG><BR>
<DD>
Uncrunches a map (array ref) into an scalar string of words seperated by ' ' and returns the 
string. This is ment to be used as a counterpart to the <A HREF="#item_crunch"><CODE>crunch()</CODE></A> method, above, possibly to 
<A HREF="#item_uncrunch"><CODE>uncrunch()</CODE></A> the output of a <A HREF="#item_run"><CODE>run()</CODE></A> call. Consider the below code (also in ./examples/ex1.pl):

<PRE>
        use AI::NeuralNet::Mesh;
        my $net = AI::NeuralNet::Mesh-&gt;new(2,3);

        for (0..3) {
                $net-&gt;learn_set([
                        $net-&gt;crunch(&quot;I love chips.&quot;),  $net-&gt;crunch(&quot;That's Junk Food!&quot;)),
                        $net-&gt;crunch(&quot;I love apples.&quot;), $net-&gt;crunch(&quot;Good, Healthy Food.&quot;)),
                        $net-&gt;crunch(&quot;I love pop.&quot;),    $net-&gt;crunch(&quot;That's Junk Food!&quot;)),
                        $net-&gt;crunch(&quot;I love oranges.&quot;),$net-&gt;crunch(&quot;Good, Healthy Food.&quot;))
                ]);
        }

        print $net-&gt;run_uc(&quot;I love corn.&quot;)),&quot;\n&quot;;</PRE>
<P>On my system, this responds with, ``Good, Healthy Food.'' If you try to run <A HREF="#item_crunch"><CODE>crunch()</CODE></A> with
``I love pop.'', though, you will probably get ``Food! apples. apples.'' (At least it returns
that on my system.) As you can see, the associations are not yet perfect, but it can make
for some interesting demos!</P>
<P></P>
<DT><STRONG><A NAME="item_crunched">$net-&gt;crunched($word);</A></STRONG><BR>
<DD>
This will return undef if the word is not in the internal crunch list, or it will return the
index of the word if it exists in the crunch list.
<P>If the word is not in the list, it will set the internal error value with a text message
that you can retrive with the <A HREF="#item_error"><CODE>error()</CODE></A> method, below.</P>
<P></P>
<DT><STRONG><A NAME="item_word">$net-&gt;word($word);</A></STRONG><BR>
<DD>
A function alias for crunched().
<P></P>
<DT><STRONG><A NAME="item_col_width">$net-&gt;col_width($width);</A></STRONG><BR>
<DD>
This is useful for formating the debugging output of Level 4 if you are learning simple 
bitmaps. This will set the debugger to automatically insert a line break after that many
elements in the map output when dumping the currently run map during a learn loop.
<P>It will return the current width when called with a 0 or undef value.</P>
<P>The column width is preserved across <A HREF="#item_load"><CODE>load()</CODE></A> and <A HREF="#item_save"><CODE>save()</CODE></A> calls.</P>
<P></P>
<DT><STRONG><A NAME="item_random">$net-&gt;random($rand);</A></STRONG><BR>
<DD>
This will set the randomness factor from the network. Default is 0.001. When called 
with no arguments, or an undef value, it will return current randomness value. When
called with a 0 value, it will disable randomness in the network. The randomness factor
is preserved across <A HREF="#item_load"><CODE>load()</CODE></A> and <A HREF="#item_save"><CODE>save()</CODE></A> calls.
<P></P>
<DT><STRONG><A NAME="item_const">$net-&gt;const($const);</A></STRONG><BR>
<DD>
This sets the run const. for the network. The run const. is a value that is added
to every input line when a set of inputs are <A HREF="#item_run"><CODE>run()</CODE></A> or <A HREF="#item_learn"><CODE>learn()</CODE></A> -ed, to prevent the
network from hanging on a 0 value. When called with no arguments, it returns the current
const. value. It defaults to 0.0001 on a newly-created network. The run const. value
is preserved across <A HREF="#item_load"><CODE>load()</CODE></A> and <A HREF="#item_save"><CODE>save()</CODE></A> calls.
<P></P>
<DT><STRONG><A NAME="item_error">$net-&gt;error();</A></STRONG><BR>
<DD>
Returns the last error message which occured in the mesh, or undef if no errors have
occured.
<P></P>
<DT><STRONG><A NAME="item_load_pcx">$net-&gt;load_pcx($filename);</A></STRONG><BR>
<DD>
NOTE: To use this function, you must have PCX::Loader installed. If you do not have
PCX::Loader installed, it will return undef and store an error for you to retrive with 
the <A HREF="#item_error"><CODE>error()</CODE></A> method, below.
<P>This is a treat... this routine will load a PCX-format file (yah, I know ... ancient 
format ... but it is the only one I could find specs for to write it in Perl. If 
anyone can get specs for any other formats, or could write a loader for them, I 
would be very grateful!) Anyways, a PCX-format file that is exactly 320x200 with 8 bits 
per pixel, with pure Perl. It returns a blessed refrence to a PCX::Loader object, which 
supports the following routinges/members. See example files ex_pcx.pl and ex_pcxl.pl in 
the ./examples/ directory.</P>
<P>The methods below are basically the same as what you would find when you type:</P>
<PRE>
        % perldoc PCX::Loader</PRE>
<P></P>
<DT><STRONG><A NAME="item_%24pcx%2D%3E%7Bimage%7D">$pcx-&gt;{image}</A></STRONG><BR>
<DD>
This is an array refrence to the entire image. The array containes exactly 64000 elements, each
element contains a number corresponding into an index of the palette array, details below.
<P></P>
<DT><STRONG><A NAME="item_%24pcx%2D%3E%7Bpalette%7D">$pcx-&gt;{palette}</A></STRONG><BR>
<DD>
This is an array ref to an AoH (array of hashes). Each element has the following three keys:

<PRE>
        $pcx-&gt;{palette}-&gt;[0]-&gt;{red};
        $pcx-&gt;{palette}-&gt;[0]-&gt;{green};
        $pcx-&gt;{palette}-&gt;[0]-&gt;{blue};</PRE>
<P>Each is in the range of 0..63, corresponding to their named color component.</P>
<P></P>
<DT><STRONG><A NAME="item_get_block">$pcx-&gt;get_block($array_ref);</A></STRONG><BR>
<DD>
Returns a rectangular block defined by an array ref in the form of:

<PRE>
        [$left,$top,$right,$bottom]</PRE>
<P>These must be in the range of 0..319 for $left and $right, and the range of 0..199 for
$top and $bottom. The block is returned as an array ref with horizontal lines in sequental order.
I.e. to get a pixel from [2,5] in the block, and $left-$right was 20, then the element in 
the array ref containing the contents of coordinates [2,5] would be found by [5*20+2] ($y*$width+$x).
</P>
<PRE>
        print $pcx-&gt;get_block(0,0,20,50)-&gt;[5*20+2];</PRE>
<P>This would print the contents of the element at block coords [2,5].</P>
<P></P>
<DT><STRONG><A NAME="item_get">$pcx-&gt;get($x,$y);</A></STRONG><BR>
<DD>
Returns the value of pixel at image coordinates $x,$y.
$x must be in the range of 0..319 and $y must be in the range of 0..199.
<P></P>
<DT><STRONG><A NAME="item_rgb">$pcx-&gt;rgb($index);</A></STRONG><BR>
<DD>
Returns a 3-element array (not array ref) with each element corresponding to the red, green, or
blue color components, respecitvely.
<P></P>
<DT><STRONG><A NAME="item_avg">$pcx-&gt;avg($index);</A></STRONG><BR>
<DD>
Returns the mean value of the red, green, and blue values at the palette index in $index.
<P></P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="what can it do">WHAT CAN IT DO?</A></H1>
<P>Rodin Porrata asked on the ai-neuralnet-backprop malining list,
``What can they [Neural Networks] do?''. In regards to that questioin,
consider the following:</P>
<P>Neural Nets are formed by simulated neurons connected together much the same
way the brain's neurons are, neural networks are able to associate and
generalize without rules.  They have solved problems in pattern recognition,
robotics, speech processing, financial predicting and signal processing, to
name a few.</P>
<P>One of the first impressive neural networks was NetTalk, which read in ASCII
text and correctly pronounced the words (producing phonemes which drove a
speech chip), even those it had never seen before.  Designed by John Hopkins
biophysicist Terry Sejnowski and Charles Rosenberg of Princeton in 1986,
this application made the Backprogagation training algorithm famous.  Using
the same paradigm, a neural network has been trained to classify sonar
returns from an undersea mine and rock.  This classifier, designed by
Sejnowski and R.  Paul Gorman, performed better than a nearest-neighbor
classifier.</P>
<P>The kinds of problems best solved by neural networks are those that people
are good at such as association, evaluation and pattern recognition.
Problems that are difficult to compute and do not require perfect answers,
just very good answers, are also best done with neural networks.  A quick,
very good response is often more desirable than a more accurate answer which
takes longer to compute.  This is especially true in robotics or industrial
controller applications.  Predictions of behavior and general analysis of
data are also affairs for neural networks.  In the financial arena, consumer
loan analysis and financial forecasting make good applications.  New network
designers are working on weather forecasts by neural networks (Myself
included).  Currently, doctors are developing medical neural networks as an
aid in diagnosis.  Attorneys and insurance companies are also working on
neural networks to help estimate the value of claims.</P>
<P>Neural networks are poor at precise calculations and serial processing. They
are also unable to predict or recognize anything that does not inherently
contain some sort of pattern.  For example, they cannot predict the lottery,
since this is a random process.  It is unlikely that a neural network could
be built which has the capacity to think as well as a person does for two
reasons.  Neural networks are terrible at deduction, or logical thinking and
the human brain is just too complex to completely simulate.  Also, some
problems are too difficult for present technology.  Real vision, for
example, is a long way off.</P>
<P>In short, Neural Networks are poor at precise calculations, but good at
association, evaluation, and pattern recognition.</P>
<P>
<HR>
<H1><A NAME="examples">EXAMPLES</A></H1>
<P>Included are several example files in the ``examples'' directory from the
distribution ZIP file.</P>
<PRE>
        ex_dow.pl
        ex_add.pl
        ex_add2.pl
        ex_pcx.pl
        ex_pcx2.pl
        ex_alpha.pl
        ex_bmp.pl
        ex_bmp2.pl
        ex_letters.pl
</PRE>
<P>Each of these includes a short explanation at the top of the file. Each of these
are ment to demonstrate simple, yet practical uses of this module.</P>
<P>
<HR>
<H1><A NAME="other included packages">OTHER INCLUDED PACKAGES</A></H1>
<P>These packages are not designed to be called directly, they are for internal use. They are
listed here simply for your refrence.</P>
<DL>
<DT><STRONG><A NAME="item_AI%3A%3ANeuralNet%3A%3AMesh%3A%3Anode">AI::NeuralNet::Mesh::node</A></STRONG><BR>
<DD>
This is the worker package of the mesh. It implements all the individual nodes of the mesh.
<P></P>
<DT><STRONG><A NAME="item_AI%3A%3ANeuralNet%3A%3AMesh%3A%3Acap">AI::NeuralNet::Mesh::cap</A></STRONG><BR>
<DD>
This is applied to the input layer of the mesh to prevent the mesh from trying to recursivly
adjust weights out throug the inputs.
<P></P>
<DT><STRONG><A NAME="item_AI%3A%3ANeuralNet%3A%3AMesh%3A%3Aoutput">AI::NeuralNet::Mesh::output</A></STRONG><BR>
<DD>
This is simply a data collector package clamped onto the output layer to record the data 
as it comes out of the mesh.
<P></P></DL>
<P>
<HR>
<H1><A NAME="bugs">BUGS</A></H1>
<P>This is the beta release of <CODE>AI::NeuralNet::Mesh</CODE>, and that holding true, I am sure 
there are probably bugs in here which I just have not found yet. If you find bugs in this module, I would 
appreciate it greatly if you could report them to me at <EM>&lt;<A HREF="mailto:jdb@wcoil.com">jdb@wcoil.com</A>&gt;</EM>,
or, even better, try to patch them yourself and figure out why the bug is being buggy, and
send me the patched code, again at <EM>&lt;<A HREF="mailto:jdb@wcoil.com">jdb@wcoil.com</A>&gt;</EM>.</P>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Josiah Bryan <EM>&lt;<A HREF="mailto:jdb@wcoil.com">jdb@wcoil.com</A>&gt;</EM></P>
<P>Copyright (c) 2000 Josiah Bryan. All rights reserved. This program is free software; 
you can redistribute it and/or modify it under the same terms as Perl itself.</P>
<P>The <CODE>AI::NeuralNet::Mesh</CODE> and related modules are free software. THEY COME WITHOUT WARRANTY OF ANY KIND.</P>
<P><B>FEEDBACK</B> - Feedback is good. Feeedback is very good. No, not for my ego. :) Please
write and let me know how your are using the module and/or how you think it could be better! 
Flames/comments/critiques are all welcome and appreciated.
</P>
<P>$Id: AI::NeuralNet::Mesh.pm, v0.20 2000/23/12 05:05:27 josiah Exp $</P>
<P>
<HR>
<H1><A NAME="download">DOWNLOAD</A></H1>
<P>You can always download the latest copy of AI::NeuralNet::Mesh
from <A HREF="http://www.josiah.countystart.com/modules/get.pl?mesh:mesh.htm">http://www.josiah.countystart.com/modules/get.pl?mesh:mesh.htm</A></P>
<P>
<HR>
<H1><A NAME="mailing list">MAILING LIST</A></H1>
<P>A mailing list has been setup for AI::NeuralNet::BackProp. I am going to use that list
to announce and discuss this module, AI::NeuralNet::Mesh. The list is for discussion of AI and 
neural net related topics as they pertain to AI::NeuralNet::BackProp and AI::NeuralNet::mesh. 
I will also announce in the group each time a new release of AI::NeuralNet::BackProp is 
available.</P>
The list address is: <A HREF="mailto:ai-neuralnet-backprop@egroups.com">ai-neuralnet-backprop@egroups.com</A> <BR>
To subscribe, send a blank email to: <A HREF="mailto:ai-neuralnet-backprop-subscribe@egroups.com">ai-neuralnet-backprop-subscribe@egroups.com</A> 

<BR><BR><BR>
<HR>
<A HREF="http://www.josiah.countystart.com/modules/get.pl?mesh:(c)"><B>AI::NeuralNet::Mesh</B></A> - An optimized, accurate neural network Mesh. By <A HREF="mailto:jdb@wcoil.com"><B>Josiah Bryan</B></A>.

</BODY>

</HTML>
